# Copyright 2018 Xanadu Quantum Technologies Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# pylint: disable=too-many-return-statements,too-many-branches,too-many-instance-attributes
"""
Python Blackbird Listener
=========================

**Module name:** :mod:`blackbird.listener`

.. currentmodule:: blackbird.listener

This module contains the main Blackbird listener,
:class:`~.BlackbirdListener`. It inherits from :class:`.blackbirdListener`
contained in the file ``blackbirdListener.py``, which is autogenerated
by ANTLR4.

In addition, a small utility function, which automates the parsing of a
Blackbird script and returns the completed listener, is included.

Summary
-------

.. autosummary::
    PYTHON_TYPES
    NUMPY_TYPES
    BlackbirdListener
    parse_blackbird

Code details
~~~~~~~~~~~~
"""
import sys

import antlr4

import numpy as np

from .blackbirdLexer import blackbirdLexer
from .blackbirdParser import blackbirdParser
from .blackbirdListener import blackbirdListener

from .error import BlackbirdErrorListener
from .auxiliary import _expression, _func, _get_arguments, _literal, _number, _VAR


PYTHON_TYPES = {
    'array': np.ndarray,
    'float': float,
    'complex': complex,
    'int': int,
    'str': str,
    'bool': bool
}
"""dict[str->type]: Mapping from the allowed Blackbird types
to the equivalent Python/NumPy types."""


NUMPY_TYPES = {
    'float': np.float64,
    'complex': np.complex128,
    'int': np.int64,
    'str': np.str,
    'bool': np.bool
}
"""dict[str->type]: Mapping from the allowed Blackbird array types
to the equivalent NumPy data types."""


class BlackbirdListener(blackbirdListener):
    """Listener to run a Blackbird program and extract the program queue and device information."""
    def __init__(self):
        self.var = {}
        """dict[str->[int, float, complex, str, bool, numpy.ndarray]]: Mapping from the
        variable names in the Blackbird script, to their declared values."""

        self.device = None
        """dict[str->[str, list, dict]]: Contains information regarding the quantum
        program/device/simulation. Important keys include:

        * ``'name'`` (str): the name of the device the Blackbird script requests to be run on
        * ``'args'`` (list): a list of positional arguments for the device
        * ``'kwargs'`` (dict): a dictionary of keyword arguments for the device
        """

        self.queue = []
        """list[dict]: List of operations to apply to the device, in temporal order.
        Each operation is contained as a dictionary, with the following keys:

        * ``'op'`` (str): the name of the operation
        * ``'args'`` (list): a list of positional arguments for the operation
        * ``'kwargs'`` (dict): a dictionary of keyword arguments for the operation
        * ``'modes'`` (list[int]): modes the operation applies to

        Note that, depending on the operation, both ``'args'`` and ``'kwargs'``
        might be empty.
        """

    def exitExpressionvar(self, ctx: blackbirdParser.ExpressionvarContext):
        """Run after exiting an expression variable.

        Args:
            ctx: variable context
        """
        name = ctx.name().getText()
        vartype = ctx.vartype().getText()

        if ctx.expression():
            value = _expression(ctx.expression())
        elif ctx.nonnumeric():
            value = _literal(ctx.nonnumeric())

        try:
            final_value = PYTHON_TYPES[vartype](value)
        except:
            raise TypeError("Var {} = {} is not of declared type {}".format(name, value, vartype)) from None

        _VAR[name] = final_value

    def exitArrayvar(self, ctx: blackbirdParser.ArrayvarContext):
        """Run after exiting an array variable.

        Args:
            ctx: array variable context
        """
        name = ctx.name().getText()
        vartype = ctx.vartype().getText()

        shape = None
        if ctx.shape():
            shape = tuple([int(i) for i in ctx.shape().getText().split(',')])

        value = []
        # loop through all children of the 'arrayval' branch
        for i in ctx.arrayval().getChildren():
            # Check if the child is an array row (this is to
            # avoid the '\n' row delimiter)
            if isinstance(i, blackbirdParser.ArrayrowContext):
                value.append([])
                for j in i.getChildren():
                    # Check if the child is not the column delimiter ','
                    if j.getText() != ',':
                        value[-1].append(_expression(j))

        try:
            final_value = np.array(value, dtype=NUMPY_TYPES[vartype])
        except:
            raise TypeError("Array var {} is not of declared type {}".format(name, vartype)) from None

        if shape is not None:
            actual_shape = final_value.shape
            if actual_shape != shape:
                raise TypeError("Array var {} has declared shape {} "
                                " but actual shape {}".format(name, shape, actual_shape)) from None

        _VAR[name] = final_value

    def exitStatement(self, ctx: blackbirdParser.StatementContext):
        """Run after exiting a quantum statement.

        Args:
            ctx: statement context
        """
        if ctx.operation():
            op = ctx.operation().getText()
        elif ctx.measure():
            op = ctx.measure().getText()

        modes = [int(i) for i in ctx.modes().getText().split(',')]

        if ctx.arguments():
            op_args, op_kwargs = _get_arguments(ctx.arguments())
            self.queue.append({
                    'op': op,
                    'args': op_args,
                    'kwargs': op_kwargs,
                    'modes': modes
                })
        else:
            self.queue.append({'op': op, 'modes': modes})

    def exitProgram(self, ctx: blackbirdParser.ProgramContext):
        """Run after exiting the program block.

        Args:
            ctx: program context
        """
        self.var.update(_VAR)
        self.device = {'name': ctx.device().getText()}

        args = []
        kwargs = {}

        if ctx.arguments():
            args, kwargs = _get_arguments(ctx.arguments())

        self.device['args'] = args
        self.device['kwargs'] = kwargs


def parse_blackbird(file, listener=BlackbirdListener):
    """Parse a blackbird program.

    Args:
        file (str): location of the .xbb blackbird file to run
        Listener (BlackbirdListener): an Blackbird listener to use to walk the AST.
            By default, the basic :class:`~.BlackbirdListener` defined above
            is used.

    Returns:
        BlackbirdListener: returns the Blackbird listener instance after
            parsing the abstract syntax tree
    """
    data = antlr4.FileStream(file)
    lexer = blackbirdLexer(data)
    stream = antlr4.CommonTokenStream(lexer)

    parser = blackbirdParser(stream)
    parser.removeErrorListeners()
    parser.addErrorListener(BlackbirdErrorListener())
    tree = parser.start()

    blackbird = listener()
    walker = antlr4.ParseTreeWalker()
    walker.walk(blackbird, tree)

    return blackbird
